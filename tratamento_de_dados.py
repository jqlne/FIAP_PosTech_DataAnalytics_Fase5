# -*- coding: utf-8 -*-
"""tratamento_de_dados.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rqLEfAU5RVZv_tnRydT-xXPViPXpeuIp
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import re
import plotly.graph_objs as go
import plotly.express as px
from scipy.stats import gaussian_kde

file_path = '/content/PEDE_PASSOS_DATASET_FIAP.csv'
pd.set_option('display.max_columns', None)
df = pd.read_csv(file_path, delimiter=';')

"""# Analisando os dados ðŸ”Ž"""

# Tem algumas inconsistÃªncias de nomenclatura em relaÃ§Ã£o ao dataset e o PDF de dicionÃ¡rio, mas acho que tudo bem...
# Reparei tambÃ©m que temos colunas faltando, sendo elas: **REC_PSICO_2021**, **REC_PSICO_2022** e **INSTITUICAO_ENSINO_ALUNO_2022**.

"""**Essa linha demonstra que o Aluno foi ingressado em 2022, e todas as outras colunas sÃ£o nulas. Uma recomendaÃ§Ã£o seria criar para cada ano um dataset separado para inÃ­cio das anÃ¡lises.** ðŸ¤”"""

pd.DataFrame(df.loc[df['NOME'] == 'ALUNO-2']).transpose().T

df.head()

df.info()

df['PONTO_VIRADA_2021'].value_counts()

"""# Tivemos adiÃ§Ã£o de colunas novas no dataset ao longo do tempo ðŸ¤”"""

len(df.columns[df.columns.str.contains('2020')])

df.columns[df.columns.str.contains('2020')]

len(df.columns[df.columns.str.contains('2021')])

df.columns[df.columns.str.contains('2021')]

len(df.columns[df.columns.str.contains('2022')])

df.columns[df.columns.str.contains('2022')]

"""# FunÃ§Ãµes reutilizÃ¡veis ðŸ¤“"""

def filter_columns(df, filters: list): # adiciono no array o padrÃ£o que existe nas colunas e que nÃ£o quero que tenha na saÃ­da final
    selected_columns = [True] * len(df.columns)  # Inicializa todas as colunas como True
    for index, column in enumerate(df.columns):
        if any(filter in column for filter in filters): selected_columns[index] = False
    return df[df.columns[selected_columns]]

def cleaning_dataset(df):
  _df = df.dropna(subset=df.columns.difference(['NOME']), how='all') # executa o dropna para todas as colunas sem visualizar a coluna NOME
  _df = _df[~_df.isna().all(axis=1)] # remove linhas com apenas NaN, se tiver algum dado na linha nÃ£o remove
  return _df

def plot_exact_counter(size, x, y, df) -> None:
  import matplotlib.pyplot as plt
  import seaborn as sns
  import pandas as pd

  plt.figure(figsize=size)
  barplot = plt.bar(y.index, y.values)
  plt.xlabel(x)
  plt.ylabel('Count')

  for index, value in enumerate(y.values):
        plt.text(index, value, round(value, 2), color='black', ha="center")

  plt.show()

def plot_bar(df, col, titulo, xaxis, yaxis='Qty'):
  grupos = df[col].value_counts()

  fig = go.Figure(
      go.Bar(
          x=grupos.index,
          y=grupos,
          text=grupos,
          textposition='auto'
      )
  )

  fig.update_layout(
      title=titulo,
      xaxis=dict(tickmode='linear'),
      xaxis_title=xaxis,
      yaxis_title=yaxis,
  )

  fig.show()

def plot_histograma(df, col, titulo, rug=True):
  # faz o cÃ¡lculo do KDE com o scipy
  data = df[col].values
  kde = gaussian_kde(data)
  x_vals = np.linspace(min(data), max(data), 1000)
  kde_vals = kde(x_vals)

  # faz o cÃ¡lculo da quantidade Ã³tima de bins (assim evitamos agrupamentos desnecessÃ¡rios)
  bins = len(np.histogram_bin_edges(data, bins='auto'))

  # cria os plots separados (histograma + kde + rug)
  # 1. histograma
  histogram = go.Histogram(x=data, nbinsx=bins, histnorm='probability density', name=f'Density: {col}')

  # 2. kde
  kde_line = go.Scatter(x=x_vals, y=kde_vals, mode='lines', name='Curve (KDE)', line=dict(color='red'))

  # 3. rug, mas apenas se ele tiver sido requisitado
  if rug:
    rug_plot = go.Scatter(
        x=data,
        y=[-0.01] * len(data),
        mode='markers',
        name='Obs',
        marker=dict(color='black', symbol='line-ns-open', size=10)
    )

  # figura principal
  fig = go.Figure()
  fig.add_trace(histogram)
  fig.add_trace(kde_line)
  fig.update_traces(texttemplate='%{y:.2%}', textposition='outside', selector=dict(type='histogram'))

  # configs
  fig.update_layout(
      title=titulo,
      xaxis_title='Value',
      yaxis_title='Frequency',
      yaxis=dict(range=[0, max(kde_vals) + 0.1]),
      bargap=0.015,
      uniformtext_mode='hide'
  )

  # configs com rug
  if rug:
    fig.add_trace(rug_plot)
    fig.update_layout(yaxis=dict(range=[-0.02, max(kde_vals) + 0.1]))
  # configs sem rug
  else:
    fig.update_layout(xaxis=dict(tickmode='linear'))

  fig.show()


def plot_boxplot(df, col, titulo):
  fig = px.box(y=df[col], points="all", title=titulo)

  fig.update_layout(
      yaxis_title='Valor'
  )

  fig.update_yaxes(dtick=1)

  fig.show()



def plot_boxplot_comparativo(df, col):
  fig = px.box(data_frame=df, x='ANO', y=col, points="all", title=f'DistribuiÃ§Ã£o do {col} comparativa', color='ANO')

  fig.update_layout(
      yaxis_title='Valor'
  )

  fig.update_yaxes(dtick=1)

  fig.show()

def analyse_corr(df):
  import seaborn as sns
  import matplotlib.pyplot as plt

  df = df.apply(pd.to_numeric, errors='coerce')

  corr_matrix = df.corr()
  plt.figure(figsize=(10, 8))
  sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', center=0)
  plt.show()

"""# DF - 2020



"""

df_2020 = filter_columns(df, ['2021', '2022'])
df_2020.head()

len(df_2020) # com NaN

df_2020.infer_objects().dtypes

#df_2020[['IDADE_ALUNO_2020','ANOS_PM_2020', 'INDE_2020', 'IAA_2020', 'IEG_2020', 'IPS_2020', 'IDA_2020', 'IPP_2020', 'IPV_2020', 'IAN_2020']]=df_2020[['IDADE_ALUNO_2020','ANOS_PM_2020', 'INDE_2020', 'IAA_2020', 'IEG_2020', 'IPS_2020', 'IDA_2020', 'IPP_2020', 'IPV_2020', 'IAN_2020']].apply(pd.to_numeric)

df_2020.iloc[1258]

df_2020.drop(index=1258,axis=1,inplace=True)

df_2020[['IDADE_ALUNO_2020','ANOS_PM_2020', 'INDE_2020', 'IAA_2020', 'IEG_2020', 'IPS_2020', 'IDA_2020', 'IPP_2020', 'IPV_2020', 'IAN_2020']]=df_2020[['IDADE_ALUNO_2020','ANOS_PM_2020', 'INDE_2020', 'IAA_2020', 'IEG_2020', 'IPS_2020', 'IDA_2020', 'IPP_2020', 'IPV_2020', 'IAN_2020']].apply(pd.to_numeric)

df_2020 = cleaning_dataset(df_2020)
len(df_2020)

df_2020['INSTITUICAO_ENSINO_ALUNO_2020'].value_counts()

df_2020.head()

df_2020['PEDRA_2020'].value_counts()

plot_exact_counter(size=(10, 6), x='PEDRA_2020', y=df_2020['PEDRA_2020'].value_counts(), df=df_2020)

analyse_corr(df_2020)

"""# **Ideias** ðŸ¤”

* PrediÃ§Ã£o de desempenho futuro e anÃ¡lise de outliers (*O que fez alguns alunos serem um dos melhores que jÃ¡ passou na Passos?*)
* PrediÃ§Ã£o para recomendaÃ§Ã£o de bolsas, intercambio, etc
* AnÃ¡lise comparatÃ³ria de 2020, 2021 e 2022
* AnÃ¡lise de alunos (*de forma individual? ðŸ¤”*) ao longo dos anos (*Ex: temos dados do 'ALUNO 1' em 2020 e 2021, jÃ¡ em 2022 nÃ£o temos dados... Seria talvez desistÃªncia?*)
* AnÃ¡lise de alunos que estÃ£o indo bem Vs alunos que nÃ£o estÃ£o indo bem. Tentar entender o porquÃª um aluno vai bem e outro nÃ£o.
* Tentar prever qual seria a â€œpedraâ€ de um novo aluno com X pontuaÃ§Ãµes de Ã­ndices em uma nova entrada

# 2021
"""

df_2021 = filter_columns(df, ['2020', '2022'])
df_2021 = cleaning_dataset(df_2021)
df_2021.head()

#df_2021[['FASE_2021','INDE_2021', 'IAA_2021', 'IEG_2021', 'IPS_2021', 'IDA_2021', 'IPP_2021', 'IPV_2021', 'IAN_2021','DEFASAGEM_2021']].apply(pd.to_numeric).dtypes

df_2021 = df_2021.replace('#NULO!', np.nan)
display(len(df_2021))
df_2021.iloc[32]

df_2021 = cleaning_dataset(df_2021)
len(df_2021)

df_2021[['FASE_2021','INDE_2021', 'IAA_2021', 'IEG_2021', 'IPS_2021', 'IDA_2021', 'IPP_2021', 'IPV_2021', 'IAN_2021','DEFASAGEM_2021']]=df_2021[['FASE_2021','INDE_2021', 'IAA_2021', 'IEG_2021', 'IPS_2021', 'IDA_2021', 'IPP_2021', 'IPV_2021', 'IAN_2021','DEFASAGEM_2021']].apply(pd.to_numeric)

df_2021['INSTITUICAO_ENSINO_ALUNO_2021'].value_counts()

df_2021['PEDRA_2021'].value_counts()

plot_exact_counter(size=(10, 6), x='PEDRA_2021', y=df_2021['PEDRA_2021'].value_counts(), df=df_2021)

analyse_corr(df_2021)

"""# 2022"""

df_2022 = filter_columns(df, ['2020', '2021'])
df_2022 = cleaning_dataset(df_2022)
df_2022.head()

df_2022[['FASE_2022','ANO_INGRESSO_2022','INDE_2022','CG_2022','CF_2022','CT_2022','IAA_2022','IEG_2022','IPS_2022','IDA_2022','IPP_2022','IPV_2022','IAN_2022','NOTA_PORT_2022','NOTA_MAT_2022','NOTA_ING_2022','QTD_AVAL_2022']]=df_2022[['FASE_2022','ANO_INGRESSO_2022','INDE_2022','CG_2022','CF_2022','CT_2022','IAA_2022','IEG_2022','IPS_2022','IDA_2022','IPP_2022','IPV_2022','IAN_2022','NOTA_PORT_2022','NOTA_MAT_2022','NOTA_ING_2022','QTD_AVAL_2022']].apply(pd.to_numeric)

df_2022['PEDRA_2022'].value_counts()

plot_exact_counter(size=(10, 6), x='PEDRA_2022', y=df_2022['PEDRA_2022'].value_counts(), df=df_2022)

analyse_corr(df_2022)

plot_bar(df_2020, 'INSTITUICAO_ENSINO_ALUNO_2020', 'Education Institutions in 2020', xaxis='Education Ins.')

plot_bar(df_2021, 'INSTITUICAO_ENSINO_ALUNO_2021', 'Education Institutions in 2021', xaxis='Education Ins.')

plot_histograma(df_2020, 'INDE_2020', 2020)
plot_histograma(df_2021.dropna(), 'INDE_2021', 2021)
plot_histograma(df_2022, 'INDE_2022', 2022)

"""## AnÃ¡lise Comparativa de 2020, 2021 e 2022

"""

import pandas as pd

def padronizar_colunas(df, ano):
    """ Remove o sufixo do ano nas colunas e adiciona a coluna 'Ano' """
    df = df.copy()
    df.columns = [col.replace(f"_{ano}", "") for col in df.columns]  # Remover o sufixo do ano
    df["Ano"] = ano  # Adicionar a coluna Ano
    return df

# Aplicar a funÃ§Ã£o nos trÃªs DataFrames
df_2020_clean = padronizar_colunas(df_2020, 2020)
df_2021_clean = padronizar_colunas(df_2021, 2021)
df_2022_clean = padronizar_colunas(df_2022, 2022)

# Unir os trÃªs DataFrames em um Ãºnico
df_merged = pd.concat([df_2020_clean, df_2021_clean, df_2022_clean], ignore_index=True)

# Exibir as primeiras linhas do novo DataFrame
df_merged.head()

import matplotlib.pyplot as plt
import seaborn as sns

# Criar um novo DataFrame apenas com mÃ©dias por ano
df_medias = pd.DataFrame({
    "Ano": ["2020", "2021", "2022"],
    "MÃ©dia das Notas": [
        df_2020["INDE_2020"].mean(axis=0),
        df_2021["INDE_2021"].mean(),
        df_2022["INDE_2022"].mean()
    ]
})

# Plotando grÃ¡fico de evoluÃ§Ã£o da mÃ©dia das notas
plt.figure(figsize=(8, 5))
sns.lineplot(data=df_medias, x="Ano", y="MÃ©dia das Notas", marker="o")
plt.xlabel("Ano")
plt.ylabel("MÃ©dia das Notas")
plt.title("EvoluÃ§Ã£o da MÃ©dia das Notas (2020-2022)")
plt.grid(True)
plt.show()

"""## AnÃ¡lise de Alunos ao Longo dos Anos

"""

df_merged

#tabela_presenca

df_merged.info()

# Criar uma tabela que mostra em quais anos cada aluno esteve presente
tabela_presenca = df_merged.pivot_table(index="NOME", columns="Ano", values="INDE", aggfunc="count").fillna(0)

# Contar quantos anos cada aluno esteve presente
tabela_presenca["anos_no_programa"] = (tabela_presenca > 0).sum(axis=1)

# Alunos que saÃ­ram do programa (estavam em 2020 ou 2021, mas nÃ£o em 2022)
alunos_desistentes = tabela_presenca[(tabela_presenca[2022] == 0) & (tabela_presenca["anos_no_programa"] > 1)]

print("Alunos que podem ter desistido:")
print(alunos_desistentes)

df_merged = df_merged.rename(columns={
    'INSTITUICAO_ENSINO_ALUNO': 'instituicao_ensino_aluno',
    'NOME': 'nome',
    'IDADE_ALUNO': 'idade_aluno',
    'ANOS_PM': 'anos_na_pm',
    'FASE_TURMA': 'fase_turma',
    'PONTO_VIRADA': 'ponto_de_virada',
    'INDE': 'indice_desenvolvimento_educacional',
    'INDE_CONCEITO': 'indice_desenvolvimento_educacional_conceito',
    'PEDRA': 'pedra',
    'DESTAQUE_IEG': 'indicador_de_engajamento',
    'DESTAQUE_IDA': 'indicador_de_aprendizagem',
    'DESTAQUE_IPV': 'indicador_de_ponto_de_virada',
    'IAA': 'indicador_de_auto_avaliacao',
    'IEG': 'indicador_de_engajamento',
    'IPS': 'indicador_psicossocial',
    'IDA': 'indicador_de_aprendizagem',
    'IPP': 'indicador_psicopedagogico',
    'IPV': 'indicador_de_ponto_de_virada',
    'IAN': 'indicador_de_adequacao_de_nivel',
    'Ano': 'ano',
    'FASE': 'fase',
    'TURMA': 'turma',
    'SINALIZADOR_INGRESSANTE': 'sinalizador_ingressante',
    'REC_EQUIPE_1': 'recomendacao_equipe_1',
    'REC_EQUIPE_2': 'recomendacao_equipe_2',
    'REC_EQUIPE_3': 'recomendacao_equipe_3',
    'REC_EQUIPE_4': 'recomendacao_equipe_4',
    'NIVEL_IDEAL': 'nivel_ideal',
    'DEFASAGEM': 'defasagem',
    'ANO_INGRESSO': 'ano_ingresso',
    'BOLSISTA': 'bolsista',
    'CG': 'classificacao_geral_ranking',
    'CF': 'classificacao_fase_ranking',
    'CT': 'classificacao_turma_ranking',
    'NOTA_PORT': 'nota_port',
    'NOTA_MAT': 'nota_mat',
    'NOTA_ING': 'nota_ing',
    'QTD_AVAL': 'qtd_aval',
    'REC_AVA_1': 'recomendacao_avaliativa_1',
    'REC_AVA_2': 'recomendacao_avaliativa_2',
    'REC_AVA_3': 'recomendacao_avaliativa_3',
    'REC_AVA_4': 'recomendacao_avaliativa_4'
})

print(df_merged.columns)

df_merged.to_csv('dados_tratados.csv', index=False)

from google.colab import files

files.download('dados_tratados.csv')

df_merged.head()